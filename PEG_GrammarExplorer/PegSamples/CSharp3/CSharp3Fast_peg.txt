<<Grammar Name="CSharp3Fast" 
	  encoding_class="utf8" 
	  host_language="C#3.0"
	  reference= "C# Language Specification Version 3.0"
	  comment= "CSharp3 parser which skips preprocessing directives"
          comment= "Uses host functions to determine character classes"
>>

//A.1.1 Line terminators
//----------------------
new_line: '\r\n' /  [\r\n#x0085#x0085#x2028#x2029];
//	Carriage return character (U+000D) /
//	Line feed character (U+000A) /
//	Carriage return character (U+000D) followed by line feed character (U+000A) /
//	Next line character (U+0085) /
//	Line separator character (U+2028) /
//	Paragraph separator character (U+2029) /
//A.1.2 Comments
//----------------------
comment: 		single_line_comment / delimited_comment;
single_line_comment: 	'//'   input_characters?;
input_characters: 	input_character+;
input_character:  	[^#x000D#x000A#x0085#x2028#x2029]; //Any Unicode character except a new_line_character
new_line_character: 	[#x000D#x000A#x0085#x2028#x2029];
//Carriage return character (U+000D)
//Line feed character (U+000A)
//Next line character (U+0085)
//Line separator character (U+2028)
//Paragraph separator character (U+2029)
delimited_comment:	'/*'  (!'*/' . )*   '*/';
//A.1.3 White space
//----------------------
whitespace:  		Zs/#x0009/#x000B/#x000C;   
//Horizontal tab character (U+0009)
//Vertical tab character (U+000B)
//Form feed character (U+000C)

//A.1.5 Unicode character escape sequences
//----------------------
unicode_escape_sequence:'\u'   hex_digit{4} / '\U'   hex_digit{8};
//A.1.6 Identifiers
//----------------------
identifier: 			 '@'   identifier_or_keyword / available_identifier;
available_identifier:  		!(keyword B) identifier_or_keyword; //An identifier_or_keyword that is not a keyword
identifier_or_keyword
{
  CSharp3Fast parent_;
  internal _identifier_or_keyword(CSharp3Fast parent)
  {
      parent_ = parent;
  }
  bool TryGetUnicodeFromHexString(out char uniCodeChar,out int readLength)
  {
      System.Diagnostics.Debug.Assert(parent_.src_[parent_.pos_] == '\\');
      uniCodeChar='\0';
      readLength=0;
      string hexString;
      if (parent_.src_[parent_.pos_ + 1] == 'u' && parent_.pos_ + 5 < parent_.srcLen_)
      {
          hexString = parent_.src_.Substring(parent_.pos_ + 2, 4);
          readLength=6;
      }
      else if (parent_.src_[parent_.pos_ + 1] == 'U' && parent_.pos_ + 9 < parent_.srcLen_)
      {
          hexString = parent_.src_.Substring(parent_.pos_ + 2, 8);
          readLength=10;
      }
      else return false;
      try
      {
          uint val = UInt32.Parse(hexString, System.Globalization.NumberStyles.HexNumber);
          uniCodeChar = (char)val;
          return (val & 0xFFFF0000) == 0;
      }
      catch (Exception) { return false; }
  }
  bool UnicodeEscapeIsLetter()
  {
      System.Diagnostics.Debug.Assert(parent_.src_[parent_.pos_] == '\\');
      char uniCodeChar;
      int readLength;
      if (!TryGetUnicodeFromHexString(out uniCodeChar, out readLength)) return false;
      if (UnicodeIsLetter(uniCodeChar))
      {
          parent_.pos_+= readLength;
          return true;
      }
      return false;
  }
  static bool UnicodeIsLetter(char c)
  {
      var cat =System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
      switch (cat)
      {
          case System.Globalization.UnicodeCategory.UppercaseLetter:
          case System.Globalization.UnicodeCategory.LowercaseLetter:
          case System.Globalization.UnicodeCategory.TitlecaseLetter:
          case System.Globalization.UnicodeCategory.ModifierLetter:
          case System.Globalization.UnicodeCategory.OtherLetter:
          case System.Globalization.UnicodeCategory.LetterNumber: return true;
          default: return false;
      }
  }
  bool UnicodeEscapeIsIdentierPartCharacter()
  {
      System.Diagnostics.Debug.Assert(parent_.src_[parent_.pos_] == '\\');
      char uniCodeChar;
      int readLength;
      if (!TryGetUnicodeFromHexString(out uniCodeChar, out readLength)) return false;
      if (UnicodeIsIdentierPartCharacter(uniCodeChar))
      {
          parent_.pos_ += readLength;
          return true;
      }
      return false;
  }
  static bool UnicodeIsIdentierPartCharacter(char c)
  {
      var  cat = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);
      switch (cat)
      {
          case System.Globalization.UnicodeCategory.UppercaseLetter:
          case System.Globalization.UnicodeCategory.LowercaseLetter:
          case System.Globalization.UnicodeCategory.TitlecaseLetter:
          case System.Globalization.UnicodeCategory.ModifierLetter:
          case System.Globalization.UnicodeCategory.OtherLetter:
          case System.Globalization.UnicodeCategory.LetterNumber: 
          case System.Globalization.UnicodeCategory.DecimalDigitNumber:
          case System.Globalization.UnicodeCategory.ConnectorPunctuation:
          case System.Globalization.UnicodeCategory.NonSpacingMark:
          case System.Globalization.UnicodeCategory.SpacingCombiningMark:
          case System.Globalization.UnicodeCategory.Format:
          return true;
          default: return false;
      }
              
  }
  internal bool ReadCSharpIdentifier_()
  {
      if( parent_.pos_ >= parent_.srcLen_ ) return false;
      if (parent_.src_[parent_.pos_] == '\\') return UnicodeEscapeIsLetter();
      if (  !(
               UnicodeIsLetter(parent_.src_[parent_.pos_])
            || parent_.src_[parent_.pos_]=='_'
            || parent_.src_[parent_.pos_] == '\\' && UnicodeEscapeIsLetter())) return false;
      while ( ++parent_.pos_ < parent_.srcLen_)
      {
          if (! (   UnicodeIsIdentierPartCharacter(parent_.src_[parent_.pos_])
                || parent_.src_[parent_.pos_] == '\\' && UnicodeEscapeIsIdentierPartCharacter())) break;
      }
      return true;
  }
}
: 	ReadCSharpIdentifier_;

//A.1.7 Keywords
//----------------------
keyword:  
'abstract'	/'as'		/'base'		/'bool'		/'break'	/
'byte'		/'case'		/'catch'	/'char'		/'checked'	/
'class'		/'const'	/'continue'	/'decimal'	/'default'	/
'delegate'	/'do'		/'double'	/'else'		/'enum'		/
'event'		/'explicit'	/'extern'	/'false'	/'finally'	/
'fixed'		/'float'	/'for'		/'foreach'	/'goto'		/
'if'		/'implicit'	/'in'		/'int'		/'interface'	/
'internal'	/'is'		/'lock'		/'long'		/'namespace'	/
'new'		/'null'		/'object'	/'operator'	/'out'		/
'override'	/'params'	/'private'	/'protected'	/'public'	/
'readonly'	/'ref'		/'return'	/'sbyte'	/'sealed'	/
'short'		/'sizeof'	/'stackalloc'	/'static'	/'string'	/
'struct'	/'switch'	/'this'		/'throw'	/'true'		/
'try'		/'typeof'	/'uint'		/'ulong'	/'unchecked'	/
'unsafe'	/'ushort'	/'using'	/'virtual'	/'void'		/
'volatile'	/'while';
//A.1.8 Literals
//----------------------
literal: 		(boolean_literal /real_literal / integer_literal / character_literal / string_literal / null_literal) S;
^boolean_literal:  	'true' B / 'false' B;
integer_literal: 	 hexadecimal_integer_literal / decimal_integer_literal ;
^decimal_integer_literal:decimal_digits   integer_type_suffix?;
decimal_digits: 	decimal_digit+;
decimal_digit: 		[0-9];
integer_type_suffix:  	[uU][lL] / [lL][uU];
^hexadecimal_integer_literal: 
			'0'[xX] hex_digits   integer_type_suffix?;
hex_digits: 		hex_digit+;
hex_digit: 		[0-9A-Fa-f];
^real_literal: 		decimal_digits  ( exponent_part   real_type_suffix? / real_type_suffix / fraction) / fraction;
fraction:		'.'   decimal_digits   exponent_part?   real_type_suffix?;
exponent_part: 		[eE]   sign?   decimal_digits;
sign:  			[+-];
real_type_suffix: 	[FfDdMm];
^character_literal: 	['] character  ['];
character: 		single_character / simple_escape_sequence / hexadecimal_escape_sequence / unicode_escape_sequence;
single_character:  	[^'\\#x000D#x000A#x0085#x2028#x2029]; // Any character except ' (U+0027), \ (U+005C), and new-line-character
simple_escape_sequence: '\\' ['"\\0abfnrtv];
hexadecimal_escape_sequence: '\\x'   hex_digit   hex_digit?   hex_digit?   hex_digit?;
^string_literal: regular_string_literal / verbatim_string_literal;
regular_string_literal: '"'   regular_string_literal_characters?   '"';
regular_string_literal_characters: regular_string_literal_character+;
regular_string_literal_character: 	
					single_regular_string_literal_character
				/	simple_escape_sequence
				/	hexadecimal_escape_sequence
				/	unicode_escape_sequence;
single_regular_string_literal_character: [^"\\#x000D#x000A#x0085#x2028#x2029]; //Any character except " (U+0022), " (U+005C), and new-line-character
verbatim_string_literal: '@"'   verbatim_string_literal_characters?  '"';
verbatim_string_literal_characters: verbatim_string_literal_character+;
verbatim_string_literal_character: single_verbatim_string_literal_character/quote_escape_sequence;
single_verbatim_string_literal_character: [^"];		//any character except "
quote_escape_sequence: '""';
null_literal:'null' B;
//A.1.9 Operators and punctuators
//----------------------
operator_or_punctuator: 
'{' /	'}' /	'[' /	']' /	'(' /	')' /	'.' /	',' /	':' /	';'  /
'+' /	'-' /	'*' /	' /' /	'%' /	'&' /	'|' /	'^' /	'!' /	'~'  /
'=' /	'<' /	'>' /	'?' /	'??' /	'::' /	'++' /	'--' /	'&&' /	'||' /
'->' /	'==' /	'!=' /	'<=' /	'>=' /	'+=' /	'-=' /	'*=' /	' /=' /	'%=' /
'&=' /	'|=' /	'^=' /	'<<' / '>>' / '<<=' / '>>=' / '=>';
right_shift: '>|>';
right_shift_assignment: '>|>=';
//A.1.10 Pre
//-----------------------processing directives
pp_directive: pp_declaration / pp_conditional / pp_line / pp_diagnostic / pp_region  / pp_pragma;
conditional_symbol: !('true' /'false') keyword B / symbolName ; //Any identifier_or_keyword except true or false
^^symbolName:    identifier;
pp_expression: whitespace*   pp_or_expression   whitespace*;
pp_or_expression: pp_and_expression  (whitespace*  '||'   whitespace*   pp_and_expression)*;
pp_and_expression: pp_equality_expression whitespace*   ('&&'   whitespace*   pp_equality_expression)*;
pp_equality_expression: pp_unary_expression (whitespace*   ('==' /'!=')   whitespace*   pp_unary_expression)*;
pp_unary_expression: ('!'   whitespace*)?  pp_primary_expression;
pp_primary_expression:
'true' / 'false' / conditional_symbol / '('   whitespace*   pp_expression   whitespace*   ')';
^^pp_declaration: whitespace*  '#'   whitespace*   ('define'/'undef')   whitespace+   conditional_symbol   pp_new_line;
pp_new_line: whitespace*   single_line_comment?   new_line;
pp_conditional: 	pp_if_section  / pp_elif_section /    pp_else_section /  pp_endif;
^^pp_if_section: 		whitespace*   '#'   whitespace*   'if'   whitespace+   pp_expression   pp_new_line   ;
^^pp_elif_section: 	whitespace*   '#'   whitespace*   'elif'   whitespace+   pp_expression   pp_new_line ;
^^pp_else_section: 	whitespace*   '#'   whitespace*   'else'  pp_new_line;
^^pp_endif: 		whitespace*   '#'   whitespace*   'endif'   pp_new_line;
^^pp_diagnostic: whitespace*   '#'   whitespace*   ('error'/'warning')   pp_message;
pp_message: new_line / whitespace*   input_characters?   new_line;
pp_region: pp_start_region  /  pp_end_region;
^^pp_start_region: whitespace*   '#'   whitespace*   'region'   pp_message;
^^pp_end_region: whitespace*   '#'   whitespace*   'endregion'   pp_message;
^^pp_line: whitespace*   '#'   whitespace*   'line'   whitespace+   line_indicator   pp_new_line;
line_indicator: decimal_digits   (whitespace+   file_name )? / 'default' / 'hidden';
file_name: '"'   file_name_characters   '"';
file_name_characters: 	file_name_character+;
file_name_character: 	!'"' input_character ;//Any input_character except "
^^pp_pragma: 		whitespace*   '#'   whitespace*   'pragma'   whitespace+   pragma_body   pp_new_line;
pragma_body: 		pragma_warning_body;
pragma_warning_body: 	'warning'   whitespace+   warning_action  (whitespace+   warning_list)?;
^^warning_action: 	'disable' / 'restore';
^^warning_list: 		decimal_digits  (whitespace*   ','   whitespace+   @decimal_digits)*;
//A.2 Syntactic grammar
//---------------------
//A.2.1 Basic concepts
//----------------------
^namespace_name: 		namespace_or_type_name;
^^type_name: 			namespace_or_type_name;
^namespace_or_type_name: 	( qualified_alias_member / name S type_argument_list? )  
			 	('.' S   @name S  type_argument_list?)*;
^^name:				identifier;
//A.2.2 Types
//----------------------
^^type: 			void_pointer / non_array_type rank_specifiers? pointers?;
^^pointer_type:			void_pointer / non_array_type rank_specifiers? pointers;
^^pointers:			'*' S ('*' S)*;
^^void_pointer:			'void' S '*' S;
value_type: 			struct_type / enum_type;
struct_type: 			type_name / simple_type ;
simple_type: 			numeric_type / ^'bool' B S;
numeric_type: 			integral_type / floating_point_type / ^'decimal' B S;
integral_type:			^('sbyte' / 'byte' / 'short' / 'ushort' / 'int' / 'uint' / 'long' / 'ulong' / 'char') B S;
floating_point_type:		^('float'/'double') B S;
^is_nullable: 			'?' S;
non_nullable_type: 		void_pointer / non_array_non_nullable_type rank_specifiers? pointers?;
enum_type: 			type_name;
non_array_reference_type: 	^'object' B S / ^'string' B S / type_name;
class_type:			non_array_reference_type;
^interface_type: 		type_name;
^array_type: 			non_array_type   rank_specifiers;
non_array_non_nullable_type:	( value_type / non_array_reference_type / type_parameter );
non_array_type: 		non_array_non_nullable_type  is_nullable? ;
rank_specifiers: 		rank_specifier+;
^^rank_specifier: 		'[' S   dim_separators?   ']' S;
dim_separators: 		(',' S)+;
^^delegate_type: 		type_name;
^^type_argument_list:		'<'  S type_arguments   '>' S;
type_arguments: 		type_argument (',' S  type_argument)*;
^^type_argument: 		type;
^^type_parameter: 		identifier S;
//A.2.3 Variables
//----------------------
^variable_reference: 		expression;
//A.2.4 Expressions
//----------------------
^^argument_list: 		argument (',' S   argument)*;
^^argument: 			expression / ^'ref' B S  @variable_reference / ^'out' B S  @variable_reference;
postfix_expression: 		primary_expression postfix_operation*;
postfix_operation:              (invocation/member_access/pointer_member_access/element_access/post_incr/post_decr);
^^invocation:			'(' S  argument_list?  @')' S;
^^member_access:		'.' S  @name S  type_argument_list?;		
^^pointer_member_access:	'->' S @name S;
^^element_access:		'[' S  @index    S ']' S;
^^index:			expression_list;
^post_incr:                     '++' S;
^post_decr:                     '--' S;
primary_expression:		literal / simple_name / parenthesized_expression /this_access / base_access / creation_expression /
				typeof_expression /  checked_expression / unchecked_expression / default_value_expression /
				special_member_access / sizeof_expression;
^^sizeof_expression:		'sizeof' S  '(' S   type   ')' S;
^simple_name: 			name B S   type_argument_list?;
^parenthesized_expression: 	'(' S   expression   ')' S;
special_member_access: 		predefined_type S  '.' S  @name S  type_argument_list?
			/	qualified_alias_member   '.' S  @name S;
^predefined_type: 		(
				'bool'	  /  'byte'	  /  'char'	  /  'decimal'  /  'double'  /  'float'	  /  'int'    /  'long' /
				'object'  /  'sbyte'	  /  'short'	  /  'string'  /  'uint'     /  'ulong'	  /  'ushort' 
				) B ;
expression_list: 		expression (',' S   @expression)*;
^this_access: 			'this' B S;
^base_access: 			'base'  S ( '.'  S @name S / '[' S  @index   @']' S );
^^post_increment_expression: 	postfix_expression   '++' S;
^^post_decrement_expression: 	postfix_expression   '--' S;
^^object_creation_expression: 	'new'  S type  
				( '(' S   argument_list?   ')'  S   object_or_collection_initializer? / object_or_collection_initializer );
object_or_collection_initializer: 
				object_initializer / collection_initializer;
^^object_initializer:		'{'  S (member_initializer_list ','? S)?   '}' S;
member_initializer_list: 	member_initializer ( ',' S  @member_initializer )*;
^member_initializer: 		member_name  S '=' S   @initializer_value;
^^initializer_value: 		expression / object_or_collection_initializer;
^^collection_initializer: 	'{' S  element_initializer_list  ','?  S @'}' S;
^^element_initializer_list: 	element_initializer  (',' S   element_initializer)*;
^^element_initializer: 		'{' S  initial_value_list    @'}' S / non_assignment_expression ;
^^initial_value_list:	        expression_list;
^^array_creation_expression: 	'new' B S
				(	non_array_type   '[' S  array_size   @']' S   rank_specifiers?   array_initializer?
				/	array_type   array_initializer 
				/    	rank_specifier   array_initializer
				);
^^array_size:			expression_list;
^^delegate_creation_expression:	'new' S  delegate_type   '(' S  expression  @')' S;
^^anonymous_object_creation_expression: 
				'new' S   anonymous_object_initializer;
^^anonymous_object_initializer:  '{' S   (member_declarator_list ','? S)?   @'}' S;
^^member_declarator_list: 	member_declarator  (',' S  @member_declarator)*;
^^member_declarator: 		member_name  S  '=' S   @expression /  full_member_access /simple_name  ;
^^full_member_access:		primary_expression (!(member_access [,)}]) postfix_operation)* member_access;
^^typeof_expression: 		'typeof' B S   '(' S   (type !generic_dimension_specifier/unbound_type_name/'void' B S)   @')' S;
^^unbound_type_name: 		(name S ('::' S @name S)?  generic_dimension_specifier?)
			 	(  '.' S   @name S  generic_dimension_specifier?)*;
^^generic_dimension_specifier: 	'<' S   commas?   @'>' S;
^commas: 			(',' S)+;
^^checked_expression: 		'checked' S    @'(' S  @expression   @')' S;
^^unchecked_expression: 	'unchecked' S  @'(' S   @expression   @')' S;
^^default_value_expression: 	'default' S    '(' S  @type   @')' S;
^unary_expression: 		cast_expression /
				postfix_expression / 
				pre_increment_expression / 
				pre_decrement_expression / 
				^'+' S   unary_expression / 
				^'-' S   unary_expression / 
				^'!' S   unary_expression / 
				^'~' S   unary_expression / 
				^'*' S   unary_expression / 
				^'&' S   unary_expression / 
                                anonymous_method_expression;
^creation_expression:           array_creation_expression / 
				object_creation_expression / 
				delegate_creation_expression / 
				anonymous_object_creation_expression;
^^pre_increment_expression: 	'++' S   unary_expression;
^^pre_decrement_expression: 	'--' S   unary_expression;
^cast_expression: 	        ('(' S   type   ')' S &([~!(]/identifier/literal/!('as' B/'is' B) keyword B)
				/ !parenthesized_expression   '(' S type ')' )
				S   unary_expression;
^multiplicative_expression: 	unary_expression ( ^[*/%] S  unary_expression )*;
^additive_expression: 		multiplicative_expression ( ^[+-] S  multiplicative_expression )*;
^shift_expression: 		additive_expression ( ^('<<' / '>>') S  additive_expression )*;
^relational_expression: 	shift_expression (^('<='/'>='/'<'/'>') S shift_expression)* 
                                (('is' B/'as' B) S non_nullable_type)? ;
^equality_expression: 		relational_expression (^('=='/'!=') S relational_expression)*;
^and_expression: 		equality_expression ('&' S equality_expression)*;
^exclusive_or_expression: 	and_expression ('^' S and_expression)*;
^inclusive_or_expression: 	exclusive_or_expression ('|' S exclusive_or_expression)*;
^conditional_and_expression: 	inclusive_or_expression ('&&' S inclusive_or_expression)*;
^conditional_or_expression: 	conditional_and_expression ('||' S conditional_and_expression)*;
^null_coalescing_expression: 	conditional_or_expression ('??' S null_coalescing_expression)?;
^conditional_expression: 	null_coalescing_expression if_else_expression?;
^if_else_expression:            ('?' S   expression   ':' S   expression);
^lambda_expression: 		anonymous_function_signature   '=>' S   anonymous_function_body;
^anonymous_method_expression: 	'delegate' S   explicit_anonymous_function_signature?   block;
^anonymous_function_signature: 	explicit_anonymous_function_signature  / implicit_anonymous_function_signature;
^explicit_anonymous_function_signature:
				'(' S  explicit_anonymous_function_parameter_list?   ')' S;
^explicit_anonymous_function_parameter_list:
                                explicit_anonymous_function_parameter (',' S explicit_anonymous_function_parameter)*;

^explicit_anonymous_function_parameter: anonymous_function_parameter_modifier?   type   parameter_name S;
^anonymous_function_parameter_modifier: ^'ref' B S / ^'out' B S;
^implicit_anonymous_function_signature:
				'(' S  implicit_anonymous_function_parameter_list?   ')' S
			/	implicit_anonymous_function_parameter;
^^implicit_anonymous_function_parameter_list:
                                implicit_anonymous_function_parameter (',' S implicit_anonymous_function_parameter)*;

implicit_anonymous_function_parameter: 
                                parameter_name S;
^anonymous_function_body: 	expression / block;
^query_expression: 		from_clause   query_body;
^from_clause: 			'from' B S   (!(name S 'in' B) type)?   name S ![;=,]  'in' B S  @expression;
^query_body: 			query_body_clauses?   select_or_group_clause   query_continuation?;
^query_body_clauses: 		query_body_clause+;
^query_body_clause: 		from_clause / let_clause / where_clause / join_into_clause  /  orderby_clause;
^let_clause: 			'let' B S   @name S  '=' S   @expression;
^where_clause: 			'where' B S   @boolean_expression;
^join_into_clause: 			'join' B S   (!(name S 'in' B) @type)?   @name S  ^'in' B S   @expression  
				 ^'on' B S   @expression   ^'equals' B S   @expression  (^'into' B S   @name S)?;
^^orderby_clause: 		'orderby' B S   @orderings;
orderings: 			ordering  (',' S   @ordering)*;
^^ordering: 			expression    ordering_direction?;
^ordering_direction: 		('ascending' / 'descending' ) B S;
select_or_group_clause: 	select_clause / group_clause;
^^select_clause: 		'select' B S   @expression;
^^group_clause:  		'group' B S   @expression   'by' B S   @expression;
^query_continuation: 		'into' B S   @name S  @query_body;
^assignment: 			unary_expression   assignment_operator S   expression;
^assignment_operator: 		'=' !'>' / '+=' / '-=' / '*=' / '/=' / '%=' / '&=' / '|=' / '^=' / '<<=' / '>>=';
^expression: 			![,)};] (assignment / non_assignment_expression) ;
^non_assignment_expression: 	query_expression / lambda_expression / conditional_expression;
^^constant_expression: 		expression;
^^boolean_expression: 		expression;
//A.2.5 Statements
//----------------------
statement: 			labeled_statement / declaration_statement / embedded_statement;
embedded_statement: 		checked_statement / unchecked_statement / using_statement  / expression_statement / 
				block / empty_statement / selection_statement / iteration_statement / 
				jump_statement / try_statement  / lock_statement / 
				 yield_statement / unsafe_statement /fixed_statement ;
^^block: 			'{' S  statement_list?   @'}' S ;
statement_list: 		statement+;
^^empty_statement: 		';' S;
^^labeled_statement: 		label S  ':' !':' S @statement;
^^label:			identifier;
^declaration_statement: 	local_variable_declaration   ';' S  /  local_constant_declaration   ';' S;
^^local_variable_declaration: 	local_variable_type   local_variable_declarators;
^local_variable_type: 		^'var' B S / type;
local_variable_declarators: 	local_variable_declarator  (',' S   @local_variable_declarator)*;
^^local_variable_declarator: 	variable_name S ('=' S local_variable_initializer)?;
^^variable_name:		identifier;
^^local_variable_initializer: 	expression / array_initializer / stackalloc_initializer;
^^stackalloc_initializer:	'stackalloc' B S   type   '[' S   expression   ']' S;
^^local_constant_declaration: 	'const' B S   @type   constant_declarators;
constant_declarators: 		constant_declarator (',' S @constant_declarator)*;
^^constant_declarator: 		constant_name S  '=' S   @constant_expression;
^^constant_name:		identifier;
^expression_statement: 		statement_expression   ';' S;
unsafe_statement:		'unsafe' B S block;
fixed_statement:		'fixed' S  '(' S   pointer_type   fixed_pointer_declarators   ')' S   embedded_statement;
fixed_pointer_declarators:	fixed_pointer_declarator (',' S fixed_pointer_declarator)*;
fixed_pointer_declarator:	name S  '=' S   fixed_pointer_initializer;
fixed_pointer_initializer:	(^'&' S)?   expression;
statement_expression: 		pre_increment_expression   / 
                                pre_decrement_expression   /
                                assignment                 / 
                                call_or_post_incr_decr    /
				object_creation_expression;
^^call_or_post_incr_decr:       primary_expression 
                                ( 
                                   (member_access/element_access) &postfix_operation / invocation / post_incr / post_decr 
                                 )+;
selection_statement: 		if_statement / switch_statement;
^if_statement: 			'if'  B S   @'(' S   boolean_expression   ')' S   embedded_statement ( 'else' S   embedded_statement)?;
^switch_statement: 		'switch' B S   @'(' S   @expression   @')' S   switch_block;
^^switch_block: 		'{' S   switch_sections?   @'}' S;
switch_sections: 		switch_section+;
^switch_section: 		switch_labels   statement_list;
switch_labels: 			switch_label+;
^^switch_label: 		'case' B S   @constant_expression   @':' S / 'default' S   @':' S ;
iteration_statement : 		while_statement / do_statement / for_statement / foreach_statement;
^while_statement: 		'while' B S   @'(' S   boolean_expression   @')' S   @embedded_statement;
^do_statement: 			'do' B S   @embedded_statement   @'while' S   @'(' S  @boolean_expression   @')' S   ';' S ;
^^for_statement: 		'for'  B S   @'(' S  for_initializer?   @';' S   for_condition?   @';' S   for_iterator?   @')' S   @embedded_statement;
^^for_initializer: 		local_variable_declaration / statement_expression_list;
^^for_condition: 		boolean_expression;
^^for_iterator: 		statement_expression_list;
statement_expression_list: 	statement_expression (',' S   @statement_expression)*;
^foreach_statement: 		'foreach' B S   @'(' S   local_variable_type   @variable_name B S  @'in' B S   @expression   @')' S   @embedded_statement;
jump_statement: 		break_statement / continue_statement / goto_statement / return_statement / throw_statement;
^^break_statement: 		'break' S   ';' S;
^^continue_statement: 		'continue' S   ';' S;
^^goto_statement: 		'goto'  B S   @(label S    / 'case' B S   @constant_expression    / 'default' S )  @';' S;
^^return_statement: 		'return' B S   expression?   @';' S;
^^throw_statement: 		'throw' B S   expression?   @';' S;
^^try_statement: 		'try' B S   @block   (catch_clauses finally_clause? / finally_clause );
^^catch_clauses: 		specific_catch_clauses   general_catch_clause? / general_catch_clause;
specific_catch_clauses: 	specific_catch_clause+;
^^specific_catch_clause: 	'catch' B S   '('  S class_type   variable_name? S  @')' S   @block;
^^general_catch_clause: 	'catch' B S   block;
^^finally_clause: 		'finally' B S   @block;
^^checked_statement: 		'checked' B S   @block;
^^unchecked_statement: 		'unchecked' B S   @block;
^^lock_statement: 		'lock' B S   @'(' S  @expression   @')' S   @embedded_statement;
^^using_statement: 		'using' B S  @'(' S   resource_acquisition   @')' S    @embedded_statement;
^^resource_acquisition: 	local_variable_declaration / expression;
^^yield_statement: 		'yield' B S   ('break' S /'return' B S   @expression)   @';' S ;
//A.2.6 Namespaces
//----------------------
^^compilation_unit: 		S extern_alias_directives?   using_directives?  global_attributes? namespace_member_declarations?
				(!./FATAL<"following code not recognized as C# source">);
^^namespace_declaration: 	'namespace' B S   @qualified_identifier S  @namespace_body   ;
^^qualified_identifier: 	name S ('.' S name S)* ;
^^namespace_body:		'{' S  extern_alias_directives?   using_directives?   namespace_member_declarations?   @'}' S;
^^extern_alias_directives:	extern_alias_directive+;
^^extern_alias_directive: 	'extern' B S   'alias' B S   alias_name S  ';' S;
^^alias_name:			identifier;
^^using_directives: 		using_directive+;
using_directive: 		using_alias_directive / using_namespace_directive;
^^using_alias_directive: 	'using' B S   using_alias_name S  '=' S   @namespace_or_type_name   @';' S;
^^using_alias_name:		identifier;	
^^using_namespace_directive: 	'using' B S   namespace_name   ';' S;
^^namespace_member_declarations:  namespace_member_declaration+;
namespace_member_declaration: 	namespace_declaration / type_declaration;
type_declaration: 		class_declaration / struct_declaration / interface_declaration / enum_declaration / delegate_declaration;
^qualified_alias_member: 	name S  '::' S   @name S  type_argument_list?;
//A.2.7 Classes
//----------------------
^^class_declaration: 		attributes?   class_modifiers?   ('partial' B S)?   'class' B S   class_name S  type_parameter_list?
				class_base?   type_parameter_constraints_clauses?   @class_body   (';' S)?;
^^class_name:			identifier;
class_modifiers: 		class_modifier+;
^^class_modifier:		('new' / 'public' / 'protected' / 'internal' / 'private' / 'abstract' / 'sealed' / 'static' / 'unsafe') B S;
^^type_parameter_list: 		'<' S   type_parameters   '>' S;
^^type_parameters: 		(attributes?   type_parameter)(',' S   attributes?   type_parameter)*;
//type_parameter: 		identifier S;
^^class_base: 			':' S  (( class_type  (',' S   interface_type_list)?) / interface_type_list);
interface_type_list: 		interface_type (',' S interface_type)*;
type_parameter_constraints_clauses: 
                                type_parameter_constraints_clause+ ;
^^type_parameter_constraints_clause: 
                                'where' B S   type_parameter   @':' S   @type_parameter_constraints;
^^type_parameter_constraints: 	primary_constraint (',' S (secondary_constraints (',' S constructor_constraint)?/constructor_constraint))? 
			/	secondary_constraints 	(',' S constructor_constraint)? ;	
^^primary_constraint: 		class_type / 'class' B S / 'struct' B S;
^^secondary_constraints: 	(interface_type / type_parameter) (',' S   (interface_type/type_parameter))*;
^^constructor_constraint: 	'new' S   '('  S @')' S;
^^class_body:			'{' S   class_member_declarations?   @'}' S;
class_member_declarations: 	class_member_declaration+;
class_member_declaration: 	constant_declaration / method_declaration / field_declaration  / property_declaration / 
				event_declaration / indexer_declaration / operator_declaration / constructor_declaration / 
				destructor_declaration / static_constructor_declaration / type_declaration;
^^constant_declaration: 	        attributes?   constant_modifiers?   'const' B S   @type   constant_declarators   ';' S;
constant_modifiers: 		constant_modifier+;
^^constant_modifier: 		('new'  / 'public' / 'protected' / 'internal' / 'private') B S;
//constant_declarators: 		constant_declarator (',' S   constant_declarator)+;
//constant_declarator: 		identifier S  '=' S   constant_expression;
^^field_declaration: 		attributes?   field_modifiers?   type   variable_declarators   ';' S;
field_modifiers: 		field_modifier+;
^^field_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private' / 'static' / 'readonly' / 'volatile' / 'unsafe') B S;
variable_declarators: 		variable_declarator (',' S   variable_declarator)*;
^^variable_declarator: 		variable_name S ('=' S   variable_initializer)?;
^^variable_initializer: 		expression / array_initializer;
^method_declaration: 		method_header   method_body;
^method_header: 			attributes?   method_modifiers?   (^'partial' B S)?   return_type   member_name S  type_parameter_list?
				'(' S   formal_parameter_list?   ')' S   type_parameter_constraints_clauses?;
method_modifiers: 		method_modifier+;
^method_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private' / 'static' / 'virtual' / 
				 'sealed' / 'override' / 'abstract' / 'extern' / 'unsafe' ) B S;
^^return_type: 			type / 'void' B S;
^interface_name_before_member: (name S type_argument_list? / qualified_alias_member)  
			       ( ^'.' S   @name S !(type_parameter_list? [({]) type_argument_list?)*;
^^method_body: 			missing_body / block;
^^missing_body:			';' S;
formal_parameter_list: 		parameter_array / fixed_parameters (',' S parameter_array)?;
fixed_parameters: 		fixed_parameter (',' S   fixed_parameter)*;
^fixed_parameter: 		attributes?   parameter_modifier?   type   parameter_name S;
^parameter_modifier: 		^('ref' / 'out' / 'this' ) B S;
^parameter_array: 		attributes?   'params' B S   @array_type   @parameter_name S;
^property_declaration: 		attributes?   property_modifiers?   type   member_name S  '{' S  @accessor_declarations   @'}' S;
property_modifiers: 		property_modifier+;
^property_modifier: 		('new' / 
                                 'public' / 
                                 'protected' / 
                                 'internal' / 
                                 'private' / 
                                 'static' / 
                                 'virtual' / 
                                 'sealed' / 
                                 'override' / 
                                 'abstract' / 
                                 'extern' /
				 'unsafe') S;
^^member_name: 			interface_name_before_member '.' S  name S / name S ;
accessor_declarations: 		get_accessor_declaration   set_accessor_declaration? / set_accessor_declaration   get_accessor_declaration?;
^^get_accessor_declaration: 	attributes?   accessor_modifier?    'get' S   accessor_body;
^^set_accessor_declaration: 	attributes?   accessor_modifier?    'set' S   accessor_body;
^^accessor_modifier: 		('protected' / 'internal' / 'private' / 'protected' B S  'internal' / 'internal' B S   'protected' )B S ;
^^accessor_body: 		block / ';' S;
^event_declaration: 		attributes?   event_modifiers?   'event' B S   type   
				(	variable_declarators  ';' S
				/ 	member_name  S '{' S   event_accessor_declarations   @'}' S
				);
event_modifiers: 		event_modifier+;
^event_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private' / 'static' / 'virtual' / 
				'sealed' / 'override' / 'abstract' / 'extern' / 'unsafe')  B S;
^event_accessor_declarations: 	add_accessor_declaration   remove_accessor_declaration / remove_accessor_declaration   add_accessor_declaration;
^^add_accessor_declaration: 	attributes?   'add' S   block;
^^remove_accessor_declaration: 	attributes?   'remove' S   block;
^indexer_declaration: 		attributes?   indexer_modifiers?   indexer_declarator   '{' S   accessor_declarations   @'}' S ;
indexer_modifiers: 		indexer_modifier+;
^indexer_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private'  / 'virtual' / 'sealed' / 
				'override' / 'abstract' / 'extern' / 'unsafe') B S;
^indexer_declarator: 		type  (interface_type   '.' S)? 'this' S    '[' S  formal_parameter_list   @']' S;
^operator_declaration: 		attributes?   operator_modifiers   operator_declarator   operator_body;
operator_modifiers: 		operator_modifier+;
^operator_modifier: 		('public' / 'static' / 'extern' / 'unsafe')S;
operator_declarator: 		unary_operator_declarator / binary_operator_declarator / conversion_operator_declarator;
^unary_operator_declarator: 	type   'operator' S   overloadable_unary_operator   '(' S   type   parameter_name   ')' S;
^overloadable_unary_operator:  	( '++' /  '--' / '+' /   '-' /    '!'  /   '~' /  'true' /   'false') S;
^binary_operator_declarator: 	type   'operator' S   overloadable_binary_operator   '(' S  type   parameter_name   ',' S   type   parameter_name  S ')' S;
^overloadable_binary_operator: 	('+' / '-' / '*' / '/' / '%' / '&' / '|' / '^' / '<<' / '>>' / '==' / '!=' / '>=' / '<=' / '>' / '<'  ) S;
^conversion_operator_declarator: ('implicit' / 'explicit' ) B S   'operator' B S   type   '(' S   type   parameter_name S   ')' S ;
^^operator_body: 		block / ';' S;
^constructor_declaration: 	attributes?   constructor_modifiers?   constructor_declarator   constructor_body;
^constructor_modifiers: 	constructor_modifier+;
^constructor_modifier: 		('public' / 'protected' / 'internal' / 'private' / 'extern' / 'unsafe') B S;
^constructor_declarator: 	name  S '(' S  formal_parameter_list?   ')' S   constructor_initializer?;
^constructor_initializer:  	':' S   (^'base'/^'this') S   '(' S   argument_list?   ')' S ;
^constructor_body: 		block / ';' S;
^static_constructor_declaration: attributes?   static_constructor_modifiers  name S  '(' S  ')' S  static_constructor_body;
^static_constructor_modifiers: 	('extern' B S)? ('unsafe' B S)? 'static' B S / 
				 'static' B S ('unsafe' B S)? ('extern' B S)? /
				'static' B S ('extern' B S) ('unsafe' B S)?/
				('extern' B S)? 'static' B S ('unsafe' B S)?/ 
				('unsafe' B S)? 'static' B S ('extern' B S)? / 
				('unsafe' B S)? ('extern' B S)? 'static' B S  ;
^static_constructor_body: 	block / ';' S;
^destructor_declaration: 	attributes?   ('extern' B S 'unsafe' S / 'unsafe' B S 'extern' S)?   '~' S   name  S '(' S  ')' S    destructor_body;
^^destructor_body: 		block / ';' S;
//A.2.8 Structs
//----------------------
^struct_declaration: 		attributes?   struct_modifiers?   (^'partial' B S)?   'struct' B S   struct_name S   type_parameter_list?
					struct_interfaces?   type_parameter_constraints_clauses?   @struct_body   ';'?;
^^struct_name:			identifier;
struct_modifiers: 		struct_modifier+;
^struct_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private' / 'unsafe')B S;
^^struct_interfaces: 		':' S   interface_type_list;
^^struct_body:			'{' S   struct_member_declarations?   @'}' S;
struct_member_declarations: 	struct_member_declaration+;
^struct_member_declaration: 	constant_declaration / field_declaration / method_declaration / property_declaration / 		
				event_declaration / indexer_declaration / operator_declaration / 
				constructor_declaration / static_constructor_declaration / type_declaration /fixed_size_buffer_declaration;
^^fixed_size_buffer_declaration:  attributes?   fixed_size_buffer_modifiers?   'fixed'  B S buffer_element_type fixed_size_buffer_declarators   ;
fixed_size_buffer_modifiers:   fixed_size_buffer_modifier+;
^^fixed_size_buffer_modifier:    ('new' / 'public' / 'protected' / 'internal' / 'private' / 'unsafe') B S;
^^buffer_element_type:		type;
fixed_size_buffer_declarators: fixed_size_buffer_declarator+;
fixed_size_buffer_declarator:  name S  '[' S   constant_expression   ']' S;
//A.2.9 Arrays
//----------------------
//array_type: 			non_array_type   rank_specifiers;
//non_array_type: 		type;
//rank_specifiers: 		rank_specifier+;
//rank_specifier:		'[' S   dim_separators?   ']' S;
//dim_separators: 		',' S  (',' S)*;
^^array_initializer:		'{' S  variable_initializer_list? (',' S)?   @'}' S;
variable_initializer_list: 	variable_initializer (',' S variable_initializer)*;
//variable_initializer: 		expression / array_initializer;
//A.2.10 Interfaces
//----------------------
^interface_declaration: 		attributes?   interface_modifiers?   ('partial' B S)?   'interface' B S   @interface_name S   type_parameter_list?
					interface_base?   type_parameter_constraints_clauses?   interface_body   ';'? S;
interface_name:			identifier;
interface_modifiers: 		interface_modifier+;
^interface_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private' / 'unsafe') B S;
^^interface_base: 		':' S   interface_type_list;
^^interface_body:		'{' S   interface_member_declarations?   '}' S;
interface_member_declarations: 	interface_member_declaration+;
^interface_member_declaration: 	interface_method_declaration / interface_property_declaration / interface_event_declaration / interface_indexer_declaration;
^interface_method_declaration: 	attributes?   ('new' B S)?   return_type   name S  type_parameter_list?
				'('  S formal_parameter_list?   ')' S   type_parameter_constraints_clauses?  ';' S ;
^interface_property_declaration: attributes?   ('new' B S)?   type   name  S '{' S  interface_accessors   '}' S;
^interface_accessors: 		attributes? 
				(  ^'get' S ';' S (attributes? ^'set' S ';' S)? 
				/  ^'set' S ';' S (attributes? ^'get' S ';' S)?
				);
^interface_event_declaration: 	attributes?   ('new' B S)?   'event' B S    type   name  S   ;
^interface_indexer_declaration:  attributes?   ('new' B S)?   type   'this' B S   '[' S   formal_parameter_list   @']' S   '{' S   interface_accessors   @'}' S;
//A.2.11 Enums
//----------------------
^enum_declaration: 		attributes?   enum_modifiers?   'enum' B S   enum_name S   enum_base?   enum_body   (';' S)?;
^^enum_name:			identifier;
^^enum_base: 			':' S integral_type;
^^enum_body:			'{'  S (enum_member_declarations (',' S)?)?   @'}' S;
enum_modifiers: 		enum_modifier+;
^enum_modifier: 			('new' / 'public' / 'protected' / 'internal' / 'private') B S;
enum_member_declarations: 	enum_member_declaration (',' S   enum_member_declaration)*;
^enum_member_declaration: 	attributes?   enumerator_name S ('=' S   @constant_expression )? S;
^^enumerator_name:		identifier;
//A.2.12 Delegates
//----------------------
^delegate_declaration: 		attributes?   delegate_modifiers?   'delegate' B S   return_type   delegate_name  S type_parameter_list?   
				'(' S  formal_parameter_list?   ')' S   type_parameter_constraints_clauses?   ';' S;
^^delegate_name:		identifier;
delegate_modifiers: 		delegate_modifier+;
^delegate_modifier: 		('new' / 'public' / 'protected' / 'internal' / 'private' / 'unsafe') B S;
//A.2.13 Attributes
//----------------------
^^global_attributes: 		global_attribute_sections;
global_attribute_sections: 	global_attribute_section+;
^global_attribute_section:	'[' S   global_attribute_target_specifier   attribute_list  (',' S)?  ']' S;
^^global_attribute_target_specifier: global_attribute_target   ':' S;
^^global_attribute_target: 	('assembly' / 'module') B S;
^^attributes: 			attribute_sections;
attribute_sections: 		attribute_section+;
^^attribute_section:		'[' S   attribute_target_specifier?   attribute_list (',' S)?  ']' S;
^^attribute_target_specifier: 	attribute_target   ':' S;
^attribute_target: 		('field' / 'event' / 'method' / 'param' / 'property' / 'return' / 'type') S;
attribute_list: 		attribute (',' S   attribute)*;
^^attribute: 			attribute_name   attribute_arguments?;
^^attribute_name:  		type_name;
^^attribute_arguments:		'('  S
				(	named_argument_list 
				/	(positional_argument_list   (',' S   named_argument_list)?)?   
				)
				')' S;
positional_argument_list: 	positional_argument  (',' S   positional_argument)*;
^^positional_argument: 		attribute_argument_expression;
named_argument_list: 		named_argument (',' S   named_argument)*;
^^named_argument: 		parameter_name S  '=' S   attribute_argument_expression;
^^parameter_name:               identifier;
attribute_argument_expression: 	expression;

//identifier end boundary B and white space  S
B: ![a-zA-Z_0-9];
S: (comment/whitespace/new_line/pp_directive )*;


//Unicode categories
Zs: [#x0020#x00a0#x1680#x180e#x2000-#x200a#x202f#x205f#x3000];

<</Grammar>>